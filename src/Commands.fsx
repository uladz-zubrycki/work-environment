#load @"Common.fsx"
#load @"Config.fsx"

open Config
open Common
open System
open System.IO
open System.Collections.Generic

Directory.SetCurrentDirectory __SOURCE_DIRECTORY__

type CommandAction = 
    | ExecuteExe of exePath: string * args: string option
    | ExecuteBat of folderToRunIn: string * batPath: string * args: string option
    | ExecuteFsx of fsxPath: string * args: string option
    | ExecuteBatTemplate of folderToRunIn: string * templatePath: string
    | ExecuteComposite of commands: string list

type Command = 
    { Name: string; 
      Description: string;
      Action: CommandAction }

let private outputFileExtension = ".bat"
let private commands = new List<Command>()

let private createExecuteBatInFolderOutput folder batCommands = 
    if folder = "." then 
        batCommands
    else
        (folder, batCommands)
        ||> sprintf """
            pushd "%s"
            %s
            popd
        """
        |> (fun s -> s.Split([| Environment.NewLine |], StringSplitOptions.RemoveEmptyEntries))
        |> Seq.map (fun s -> s.Trim())
        |> String.concat Environment.NewLine

let private createCommandOutput = function
    | ExecuteExe(exePath, args) -> 
        let args = if args.IsSome then args.Value else ""
        sprintf "start \"\" \"%s\" \"%s\"" exePath args
    | ExecuteBat(folderToRunIn, batPath, args) ->
        let args = if args.IsSome then " " + args.Value else ""
        let batCommands = sprintf "call %s%s" batPath args
        createExecuteBatInFolderOutput folderToRunIn batCommands
    | ExecuteFsx(fsxPath, args) ->
        let args = if args.IsSome then " -- " + args.Value else ""
        sprintf "\"%s\" \"%s\"%s" config.FsiPath  fsxPath  args
    | ExecuteBatTemplate(folderToRunIn, templatePath) ->
        let batCommands = File.ReadAllText templatePath
        createExecuteBatInFolderOutput folderToRunIn batCommands
    | ExecuteComposite(commands) -> 
        commands 
        |> Seq.map (fun c -> "call " + c)
        |> String.concat Environment.NewLine

let private createCommandHeader(cmd: Command) =
    [
        "@echo off"; 
        "cls"; 
        ""; 
        "REM ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;";
        "REM File is autogenerated. Any manual modifications will be lost.";
        "REM ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;";
    ]
    |> String.concat Environment.NewLine

let private getCommandOutputPath(outputDirectory: string) (cmd: Command) = outputDirectory @@ cmd.Name + outputFileExtension

let private generateCommand(outputDirectory: string) (cmd: Command) = 
    let outputFilePath = getCommandOutputPath outputDirectory cmd
    if File.Exists outputFilePath then File.Delete outputFilePath
    File.WriteAllText(outputFilePath, createCommandHeader cmd)
    File.AppendAllText(outputFilePath, Environment.NewLine + Environment.NewLine)
    File.AppendAllText(outputFilePath, createCommandOutput cmd.Action)
    printInfo <| sprintf "Command '%s' created." cmd.Name 

let defineCommand cmd = commands.Add cmd
let generateCommands outputDirectory = 
    if not (Directory.Exists outputDirectory) then
        Directory.CreateDirectory outputDirectory |> ignore
    
    printInfo <| sprintf "Generating commands to '%s'." outputDirectory
    commands |> Seq.iter (generateCommand outputDirectory)
    printSuccess "All commands are generated successfully."

let deleteCommands outputDirectory = 
    printInfo <| sprintf "Deleting commands from '%s'." outputDirectory
    commands
    |> Seq.map (fun cmd -> (cmd.Name, getCommandOutputPath outputDirectory cmd))
    |> Seq.iter (fun (name, path) -> 
        if File.Exists path then 
            File.Delete path
            printInfo <| sprintf "Command '%s' deleted." name
        else 
            printWarn <| sprintf "Can't delete command '%s'. File not found at '%s'" name path)
    printSuccess "Commands are deleted successfully."